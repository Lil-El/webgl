# 颜色与纹理

## 绘制三个不同大小的点

### 1.0

设置三个点，每个点的大小不一样；需要创建两个缓冲区对象，并设置坐标、大小的类型化数组，将数据传入

### 1.1 **vertexAttribPointer**

如果点过多，代码也会很多；所以 1.1 要通过设置一个缓冲区对象来实现该目标

vertexAttribPointer(location,size,type,normalized,stride,offset)，将 gl.ARRAY_BUFFER 的缓冲区对象分配给由 location 指定的 attribute 变量

- location：指定待分配 attribute 变量的存储位置
- size：指定缓冲区中每个顶点的分量个数（1-4）
- type：数据格式
- normalized：true 或 false，表示是否将非浮点的数据归一化到[0,1]或[-1,1]区间
- stride：步进参数
- offset：偏移参数

> 每三个值是一个点的信息（stride），前两个是坐标信息（offset=0），后一个是尺寸信息（offset=2）

### 2

绘制三个不同颜色的点、绘制彩色三角形

在 gl.drawArrays 是 n 为 3，所以顶点着色器要执行 3 次

- 每一次都会将顶点存储到装配区，
- 然后去装配图形（根据第一个参数），// gl.drawArrays(gl.TRIANGLES, 0, n);
- 最后由片元着色器去转换；这个转换的过程（将装配好的集几何图形转化为片元）被称为“光栅化”

> **varying 变量**
>
> 顶点着色器的 varying 变量会在片元着色器中使用，但是在使用之前经历了内插的过程。所以顶点和片元的 varying 的变量实际上是不同的。这也是为什么将 varying 变量称为**变化**的原因。
>
> 2.png
>
> 颜色值的内插：webgl 自动计算中间（片元）的颜色值
>
> 蓝色（0,0,1）----------->红色(1,0,0)
>
>             |
>             | 光栅化
>             |
>
> 蓝色(0,0,1)-(0.25,0,0.75)-(0.5,0,0.5)-(0.75,0,0.25)-(1,0,0)红色

# 3.在矩形表面贴上图像

为了模拟一个真实的墙壁，需要创建很多三角形；可以使用**三维图形学**的**纹理映射**技术；

> 将一个图像映射到一个几何图形的表面上。这个图形就可以成为**纹理图像或纹理**

> **纹理映射的作用**：根据纹理图像，将光栅化之后的每个片元涂上合适的颜色。组成纹理图像的像素被称为**纹素**
> 纹理映射步骤：

- 准备纹理图像
- 为几何图形配置纹理映射方式
- 加载纹理图像，对其配置，以在 webgl 中使用
- 在片元着色器中将纹素从纹理中抽取出来，将纹素的颜色赋给片元

## 纹理坐标

是一个新的坐标系统。在纹理坐标上可以获取纹素颜色。WebGL 的纹理坐标系统是二维的，为了与 x,y 区分，WebGL 使用 s 和 t 命名纹理坐标系统。

将 d1,,,d4 映射到 o1,,,o4

```
- 纹理坐标系统
t
| d1(0,1)                     d2(1,1)
|------------------------------
|                              |
|                              |
|                              |
|          纹理图像             |
|                              |
|                    o---------|------>（0.7,0.4）的纹素
|                              |
|                              |
|------------------------------>s
(0,0)d3                      d4(1,0)
==================================================
- WebGL坐标系统
        (0,0.5) | y
o1              |             o2
                |
                |
                | (0,0)        x
------------------------------->
(-0.5,0)        |             (0.5,0)
                |
                |
                |
o3              | (0,-0.5)    o4
```

### CODE：

- 开启 0 号纹理单元：gl.activeTexture(gl.TEXTURE0);
  webgl 通过**纹理单元**机制同时使用多个*纹理*。每个纹理单元有一个单元编号来管理一个纹理图像。

> 如果你只有一个纹理图像，也要指定一个纹理单元

纹理单元由硬件和浏览器的 WebGL 实现。至少支持 8 个单元：内置变量 gl.TEXTURE0,,,,,,gl.TEXTURE7。各表示一个纹理单元。

- 绑定纹理对象向 target 中：gl.bindTexture(gl.TEXTURE_2D, texture)

告诉 WebGL 系统纹理对象使用哪种类型纹理，需要绑定纹理对象，类似于缓冲区；WebGL 支持两种纹理类型，gl.TEXTURE_2D、gl.TEXTURE_CUBE_MAP

- 设置纹理参数：gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)

  - param2：
    - TEXTURE_MIN_FILTER：纹理缩小
    - MAG：纹理放大
    - TEXTURE_WRAP_S：纹理水平填充
    - Y：纹理垂直填充
  - param3: 看书吧。

  > 设置纹理图像映射到图形上的具体方法：如何根据纹理坐标获取纹素颜色，按哪种方式重复填充纹理

// TODO:175 页“在矩形表面贴上图像”-用示例程序做试验
